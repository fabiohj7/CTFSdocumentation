from binascii import crc_hqx

from Crypto.Util.number import *

p = getPrime(1024)
q = getPrime(1024)

n = p * q
n = 10564138776494961592014999649037456550575382342808603854749436027195501416732462075688995673939606183123561300630136824493064895936898026009104455605012656112227514866064565891419378050994219942479391748895230609700734689313646635542548646360048189895973084184133523557171393285803689091414097848899969143402526024074373298517865298596472709363144493360685098579242747286374667924925824418993057439374115204031395552316508548814416927671149296240291698782267318342722947218349127747750102113632548814928601458613079803549610741586798881477552743114563683288557678332273321812700473448697037721641398720563971130513427
e = 65537
tot = (p - 1) * (q - 1)
d = pow(e, -1, tot)

flag = bytes_to_long(open("flag.txt", "rb").read())
ct = pow(flag, e, n)
ct = 7549745978887276200048663235865207211393830036323940577247407159984750000505546954032203412288634152346210375670476176689063238149014106298772359390786460527125765070874126266221761613498449276350453023033183293804693250319740934227075262998515802582190701542838406863586219538264109391273899582677090014971138710777571973920373138537213681423777708522064001027502530502716482801524189704418289414864675685479246672041783223650985583220937562051467375918557928637008223005260066479223092455507486529334128813895424718400953762651563807840966584892969283198817905491060375143171138752481103830336981774581917863768973

#signature = pow(flag, d, n) # no, im not gonna do that
signature = pow(flag, crc_hqx(long_to_bytes(d), 42), n)

print(f"{n = }")
print(f"{ct = }")
print(f"{signature = }")

signature = 1275844821761484983821340844185575393419792337993640612766980471786977428905226540853335720384123385452029977656072418163973282187758615881752669563780394774633730989087558776171213164303749873793794423254467399925071664163215290516803252776553092090878851242467651143197066297392861056333834850421091466941338571527809879833005764896187139966615733057849199417410243212949781433565368562991243818187206912462908282367755241374542822443478131348101833178421826523712810049110209083887706516764828471192354631913614281317137232427617291828563280573927573115346417103439835614082100305586578385614623425362545483289428


def mod_inverse(a, m):

    def egcd(a, b):
        if a == 0:
            return (b, 0, 1)
        else:
            g, y, x = egcd(b % a, a)
            return (g, x - (b // a) * y, y)

    g, x, _ = egcd(a, m)
    if g != 1:
        return x % m  # This might not be a true modular inverse
    else:
        return x % m


# Then use it in your code
ans = pow(signature, mod_inverse(crc_hqx(long_to_bytes(d), 42), tot), n)


def long_to_bytes(x):
    return x.to_bytes((x.bit_length() + 7) // 8, byteorder='big')


bytes_result = long_to_bytes(ans)

# Decode the bytes to text
text_result = bytes_result.decode('utf-8', errors='ignore')

# Print the text
print("flag: ", text_result)
