# Enumeration & Exploitation Challenges

## Python 1 (Easy)

The challenge is to find an input to this program that will give you the correct validation.

[Python File](python1.py)

---

Examining the python file I was able to see that the code will convert the input into ASCII code.

Then it gives some conditionals

- It has to be = 1000
- The length has to be = 10
- And the second letter equal to = 83

There are a lot of answers for this flag, but as long as you comply with the conditionals the flag
will work.

My approach to this answer was to write down an array `arr[9]` with the position `arr[1] = 83`.

Then I just placed a number that would be equal to a letter and that adding it to the others would
equal 1000.

## Python 2 (Easy)

The challenge is to find an input to this program that will give you the correct validation.

[Python File](PYTHON2.pyc)

---

We are given a .pyc file, which is a compiled version of a pythong file.

To uncompile this file we downloaded python's uncompyle6 tool

To download:
`pip install uncompyle6`

I uncompiled the file in terminal using the following command

`uncompyle6 <PYTHON2.pyc>`

Then I copied the output into a new file

[Uncompiled Python File](decpython2.py)

From the code we can see that there is a list and our input has to be equal to the length of the list.
Then each character of the list is converted to ASCII again, but to every character is adding the value
of 7. Also, if the character is bigger that 'z' it will send the value back to the character 'a'.
To get the flag you input has to be equal to the list.

My approach to this challenge was to reverse the algorithm. I changed the basic operations, instead of adding
I subtracted 7, and change the conditionals so that if the code goes lower than the value of 'a' it would go
directly to the vaue of 'z'.

You can see the program here:

[Answer Python File](py2answer.py)
